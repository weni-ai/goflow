package actions

import (
	"fmt"

	"github.com/nyaruka/gocommon/jsonx"
	"github.com/nyaruka/goflow/flows"
	"github.com/nyaruka/goflow/flows/events"
)

func init() {
	registerType(TypeCallWeniGPT, func() flows.Action { return &CallWeniGPTAction{} })
}

// TypeCallWeniGPT is the type for the call weniGPT action
const TypeCallWeniGPT string = "call_wenigpt"

type CallWeniGPTAction struct {
	baseAction
	onlineAction

	KnowledgeBase string `json:"knowledge_base"`
	Input         string `json:"input"`
	ResultName    string `json:"result_name,omitempty"`
}

// NewCallWeniGPT creates a new call wenigpt action
func NewCallWeniGPT(uuid flows.ActionUUID, knowledgeBase string, input string, resultName string) *CallWeniGPTAction {
	return &CallWeniGPTAction{
		baseAction:    newBaseAction(TypeCallWeniGPT, uuid),
		KnowledgeBase: knowledgeBase,
		Input:         input,
		ResultName:    resultName,
	}
}

// Execute runs this action
func (a *CallWeniGPTAction) Execute(run flows.FlowRun, step flows.Step, logModifier flows.ModifierCallback, logEvent flows.EventCallback) error {

	// substitute any variables in our url
	input, err := run.EvaluateTemplate(a.Input)
	if err != nil {
		logEvent(events.NewError(err))
	}
	if input == "" {
		logEvent(events.NewErrorf("input evaluated to empty string"))
		return nil
	}

	kb := a.KnowledgeBase

	return a.call(run, step, input, kb, logEvent)
}

var token string
var apiUrl = "https://nlp.bothub.it"

func SetWeniGPTToken(t string) {
	token = t
}

func SetWeniGPTAPIURL(url string) {
	apiUrl = url
}

// Execute runs this action
func (a *CallWeniGPTAction) call(run flows.FlowRun, step flows.Step, input string, kb string, logEvent flows.EventCallback) error {
	svc, err := run.Session().Engine().Services().WeniGPT(run.Session())
	if err != nil {
		logEvent(events.NewError(err))
		return nil
	}

	url := apiUrl + "/v2/question-answering/"

	call, err := svc.Call(run.Session(), input, kb, token, url)

	if err != nil {
		logEvent(events.NewError(err))
	}
	if call != nil {
		a.updateWeniGPT(run, call)

		status := callStatusWeniGPT(call, err)

		c := &flows.WebhookCall{
			Trace:           call.Trace,
			ResponseJSON:    call.ResponseBody,
			ResponseCleaned: false,
		}

		if c.Trace.Response.StatusCode >= 400 {
			status = flows.CallStatusConnectionError
			logEvent(events.NewWebhookCalled(c, status, ""))
			return fmt.Errorf("error: status code equals '%d' and not 200", c.Trace.Response.StatusCode)
		}

		logEvent(events.NewWebhookCalled(c, status, ""))

		if a.ResultName != "" {
			a.saveWeniGPTResult(run, step, a.ResultName, call, status, logEvent)
		}
	}

	return nil
}

// Results enumerates any results generated by this flow object
func (a *CallWeniGPTAction) Results(include func(*flows.ResultInfo)) {
	if a.ResultName != "" {
		include(flows.NewResultInfo(a.ResultName, weniGPTCategories))
	}
}

// determines the wenigpt status from the HTTP status code
func callStatusWeniGPT(call *flows.WeniGPTCall, err error) flows.CallStatus {

	response := struct {
		Answer string `json:"answer"`
		Other  bool   `json:"other"`
	}{}

	jsonx.Unmarshal(call.ResponseJSON, &response)

	if call.Response == nil || err != nil {
		return flows.CallStatusConnectionError
	}
	if call.Response.StatusCode/100 == 2 {
		return flows.CallStatusSuccess
	} else if response.Other {
		return flows.CallStatusResponseOtherWeniGPT
	}

	return flows.CallStatusResponseError
}
