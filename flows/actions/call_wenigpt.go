package actions

import (
	"github.com/nyaruka/goflow/flows"
	"github.com/nyaruka/goflow/flows/events"
)

func init() {
	registerType(TypeCallWeniGPT, func() flows.Action { return &CallWeniGPTAction{} })
}

// TypeCallWeniGPT is the type for the call weniGPT action
const TypeCallWeniGPT string = "call_wenigpt"

type CallWeniGPTAction struct {
	baseAction
	onlineAction

	KnowledgeBase string `json:"knowledge_base"`
	Input         string `json:"input"`
	ResultName    string `json:"result_name,omitempty"`
}

// NewCallWeniGPT creates a new call wenigpt action
func NewCallWeniGPT(uuid flows.ActionUUID, knowledgeBase string, input string, resultName string) *CallWeniGPTAction {
	return &CallWeniGPTAction{
		baseAction:    newBaseAction(TypeCallWeniGPT, uuid),
		KnowledgeBase: knowledgeBase,
		Input:         input,
		ResultName:    resultName,
	}
}

// Execute runs this action
func (a *CallWeniGPTAction) Execute(run flows.FlowRun, step flows.Step, logModifier flows.ModifierCallback, logEvent flows.EventCallback) error {

	// substitute any variables in our url
	input, err := run.EvaluateTemplate(a.Input)
	if err != nil {
		logEvent(events.NewError(err))
	}
	if input == "" {
		logEvent(events.NewErrorf("input evaluated to empty string"))
		return nil
	}

	kb := a.KnowledgeBase

	return a.call(run, step, input, kb, logEvent)
}

// Execute runs this action
func (a *CallWeniGPTAction) call(run flows.FlowRun, step flows.Step, input string, kb string, logEvent flows.EventCallback) error {
	svc, err := run.Session().Engine().Services().WeniGPT(run.Session())
	if err != nil {
		logEvent(events.NewError(err))
		return nil
	}

	call, err := svc.Call(run.Session(), input, kb, string(run.Contact().Language()))

	if err != nil {
		logEvent(events.NewError(err))
	}
	if call != nil {
		a.updateWeniGPT(run, call)

		status := callStatusWeniGPT(call, err)
		logEvent(events.NewWeniGPTCalled(call, status, ""))

		c := &flows.WebhookCall{
			Trace:           call.Trace,
			ResponseJSON:    call.ResponseBody,
			ResponseCleaned: false,
		}

		logEvent(events.NewWebhookCalled(c, status, ""))

		if a.ResultName != "" {
			a.saveWeniGPTResult(run, step, a.ResultName, call, status, logEvent)
		}
	}

	return nil
}

// Results enumerates any results generated by this flow object
func (a *CallWeniGPTAction) Results(include func(*flows.ResultInfo)) {
	if a.ResultName != "" {
		include(flows.NewResultInfo(a.ResultName, webhookCategories))
	}
}

// determines the wenigpt status from the HTTP status code
func callStatusWeniGPT(call *flows.WeniGPTCall, err error) flows.CallStatus {
	if call.Response == nil || err != nil {
		return flows.CallStatusConnectionError
	}
	if call.Response.StatusCode/100 == 2 {
		return flows.CallStatusSuccess
	}

	return flows.CallStatusResponseError
}
